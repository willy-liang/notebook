# Echarts

- `Echarts`是使用`JavaScript`实现的开源可视化库，底层依赖矢量图形库`ZRender`，可高度个性化定制数据可视化图表。主要配置：`series 、xAxis 、yAxis 、grid 、tooltip 、title 、legend 、color`
- series：系列列表。每个系列通过 `type` 决定自己的图表类型，可以多个图表重叠。

- xAxis：直角坐标系 grid 中的 x 轴

  - boundaryGap: 坐标轴两边留白策略 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。
- yAxis：直角坐标系 grid 中的 y 轴
- grid：直角坐标系内绘图网格。 
- title：标题组件
- tooltip：提示框组件，用于配置鼠标滑过或点击图标时的显示框
- legend：图例组件(通用配置），用于筛选系列，需和series配合使用
- color：调色盘颜色列表，数据堆叠，同个类目轴上系列配置相同的`stack`值，后一个系列的值会在前一个系列的值上相加。
- toolbox：工具栏（内置导出图片、数据导图、动态类型转换、数据区域缩放、重置五个工具）

#### 注意

- **`legend`内的`data`值与`series`内的`name`值不一致**，将会导致拿到后台传递的数据后，页面依旧不会渲染成功。
- **不给`canvas`（即描绘数据表的div标签）设定宽高值**，将会导致数据表无法显示出来。
- `xAxis或yAxis`里面的值与`series`中的data值（看描述什么图），将会导致数据表无法正确渲染。

#### 建议：

- 数据报表不能`mounted`生命周期中。
- 图标挂载之前判断是否有数据，当数据请求回来以后再进行挂载。或者使用`$nextTick()`方法，让图表在下一个tick或者本轮tick的微任务阶段挂载。
- 父组件要使用中间变量的方式向子组件传递所需要的数据。（即在子组件的data中定义变量，再通过watch侦听父组件传来的值，且把传来的值赋给data的变量中，调用的是data的变量）
- 在父组件数据发生改变后子组件要做到实时更新，就需要子组件用watch来监听数据的变化，而且对象类型和数组类型的监听方式不同。

![image-20210923195408033](image/image-20210923195408033.png)

## demo

### 图表大小随窗口变化自适应

```js
//在方法中编写	
window.onresize = function () {
       this.myChart.resize();
       // .resize后加括号哦，这里还可以写其他的事件
};
```

> 注意：必须要给容器一个高度，否则高度为0，图表不显示
> 一般是把图表写在子组件中，然后把子组件的宽高定义为`100%`，再在父组件中通过`ref属性`绑定子组件，再调用`window.onresize`。

```son.vue
<template>
    <div class="m-box">
        <div>图表<div>
                <div class="m-subject">
                    <div class="m-echarts" ref="myCharts"></div>
                </div>
            </div>
</template>

<script>
    import echarts from 'echarts'
    export default {
        props: { xData: Array, },
        data() {
            return {
                xxData: [],
                xxDataName: [],
                xxDataValue: [],
                instance: {},
            }
        },
        methods: {
            resize() {
                this.instance.echart.resize();
            },
            initEcharts() {
                this.instance.echart = echarts.init(this.$refs.myCharts);
            },
            setEchartsOption() {
                this.instance.echart.setOption({
                    legend: {
                        data: ['DATA1']
                    },
                    xAxis: [{  //x轴坐标数据
                        type: 'category',
                        boundaryGap: false,
                        data: this.xxDataName //['周一','周二','周三','周四','周五','周六','周日']
                    }],
                    yAxis: [{   //y轴坐标数据
                        type: 'value',
                        axisLabel: {
                            formatter: '{value} °'
                        }
                    }],
                    series: [  //驱动图表生成的数据内容数组，几条折现，数组中就会有几个对应对象，来表示对应的折线
                        {
                            name: "DATA1",
                            type: "line",  //pie->饼状图  line->折线图  bar->柱状图
                            data: this.xxDataValue,//[11, 11, 15, 13, 12, 13, 10],
                        },
                    ]
                });
            },
        },
        create() {
            this.yData();
            this.xData();
        },
        mounted() {
            this.initEcharts();
            this.setEchartsOption();
        },
        watch: {
            xData: function (newVal, oldVal) {
                this.xxData = newVal;
                for (let i in this.xxData) {
                    this.xxDataName.push(this.xxData[i].name);
                    this.xxDataValue.push(parseInt(this.xxData[i].value));
                }
                this.setEchartsOption();
            }
        }
    }
</script>
<style lang="less">
    .m-box {
        width: 100%;
        height: 100%;

        .m-subject {
            width: 100%;
            height: 100%;

            .m-echarts {
                width: 100%;
                height: 100%;
            }
        }
    }
</style>
```

```App.vue
<template>
  <div id="app">
    <div class="charts">
      <data-table :xData="xData" class="charts" ref="dataTable"></data-table>
    </div>
  </div>
</template>

<script>
  import { xData } from './components/data.js';
  import dataTable from './components/son'

  export default {
    name: 'App',
    data() {
      return { xData: [], }
    },
    methods: {
      getData() { this.xData = xData; },
    },
    components: { xData, dataTable },
    mounted() {
      this.getData();
      window.onresize = () => {	//通过定义CSS样式宽高100%，和这函数来实现满屏显示图表
        this.$refs.dataTable.resize();
      }
    },
  }
</script>
<style lang="less">
  html,body,#app {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
  }
  .charts {
    width: 100%;
    height: 100%;
  }
</style>
```



## 图状

#### 柱状图`bar`



#### 折线图`line`

- serires中的type设置为line
- 折线图常见效果
  - 最大值/最小值/平均值：markPoint/ markLine / markArea
  - 线条填充：smooth lineStyle
  - 填充风格：areaStyle
  - 紧挨边缘：boundaryGap
  - 脱离0值比例：scale
  - 堆叠图：stack
- 折线图特点：折线图常用于分析数据随时间的变化趋势



#### 散点图`scatter`

- 基本的散点图
  - x轴和y轴的数据是一个二维数组
  - series中的type设置为scatter
  - xAxis和yAxis中的type设置为value

- 气泡图效果
  - 散点的大小不同：`symbolSize`
  - 散点的颜色不同：`itemStyle.color`
  - 涟漪动画效果：`type:effectScatter,showEffectOn:'emphasis',rippleEffect:{}`
- 散点图特点
  - 散点图可推断出不同维度数据之间的相关性
  - 散点图经常用在地图的标注上

#### 饼图`pie`



#### 直角坐标系

- 直角坐标系图标：柱状图、折线图、散点图
- 配置：网格`grid`、坐标轴`axis`、区域缩放`dataZoom`
- 网格`grid`
  - `grid`是用来控制直角坐标系的布局和大小
  - x轴和y轴是在grid的基础上进行绘制
  - 显示grid：`show`
  - grid的边框：`borderWidth`、`borderColor`
  - grid的位置和大小：`left | top | right | bottom`
- 坐标轴`axis`
  - 坐标轴分x轴`xAxis`和y轴`yAxis`
  - 坐标轴类型type：
    - value：数值轴，自动会从目标数据读取数据
    - category：类目轴，该类型必须通过data设置类目数据
  - 显示位置`position`：
    - xAxis：可取值为top/bottom
    - yAxis：可取值为left/right

- 区域缩放`dataZoom`
  - dataZoom用于区域缩放，对数据范围过滤(x、y轴都可)
  - dataZoom是一个数组，可配置多个区域缩放器
  - 类型type：
    - slider:滑块过滤
    - inside：内置过滤，依赖鼠标滚轮或者双指缩放
  - 指明产生的作用轴：
    - xAxisIndex：设置缩放组件控制的是哪个x轴，一般为0
    - yAxisIndex：设置缩放组件控制的是哪个y轴，一般为0
  - 指明初始状态的缩放情况：start、end（注意：值为百分比的值，100为所有，0为无）



# ag-Grid

### 单元格事件

- onRowClicked行点击事件
- onCellClicked单击单元格事件（放在定义单元格的某列中，就只能该列点击触发该事件；放在定义外面，点击所有列都生效）
- onCellDoubleClicked双击单元格事件（放在定义单元格的某列中，就只能该列点击触发该事件；放在定义外面，点击所有列都生效）
- 全部事件列表

#### `onRowClicked`行点击事件

> 注意：此事件发生在点击表格行的时候，事件写在gridOptions下。

```js
this.personGridOptions = gridOptions();
// 获取左边点击行的数据
this.personGridOptions.onCellClicked = event => {
  //event.data 选中的行内数据，event.event 为鼠标事件，
  console.log(event);
  let itxst = JSON.stringify(event.data);
  console(itxst);
}
```

#### 获取集中的单元格值

1. 通过`let focusCell = gridOptions.getFocusedCell()`获取焦点单元格；
2. 或使用`onCellFocused`事件。
   - 两者都提供了`rowIndex:number, column:column `：行数索引：数字，列：列

```js
// 1.使用行索引检索行节点
let row = gridOptions.api.getDisplayedRowAtIndex(rowIndex);

// 2. 之后，可以使用这些属性来检索单元格的原始值
let cellValue = gridOptions.api.getValue(colkey, row.node);
```



# electron

- 桌面应用开发`electron`，可以理解为把浏览器中的网站通过打包嵌套到app中

```bash
# 安装
npm install electron -g
npm install create-electron-app -g

# 创建项目
create-electron-app app-name

# 启动项目
cd app-name
npm run start
```



# 错误解义

```js
error 1: Out of memory 内存溢出
error 2: Identifier expected 缺标识符
error 3: Unknown identifier 未定义的标识符
error 4: Duplicate identifier 重复定义的标识符
error 5: Syntax error 语法错误
error 6: Error in real constant 实型常量错误
error 7: Error in integer constant 整型常量错误
error 8: String constant exceeds line 字符串常量超过一行
error 10: Unexpected end of file 文件非正常结束
error 11: Line too long 行太长
error 12: Type identifier expected 未定义的类型标识符
error 13: Too many open files 打开文件太多
error 14: Invalid file name 无效的文件名
error 15: File not found 文件未找到
error 16: Disk full 磁盘满
error 17: Invalid compiler directive 无效的编译命令
error 18: Too many files 文件太多
error 19: Undefined type in pointer def 指针定义中未定义类型
error 20: Variable identifier expected 缺变量标识符

error 21: Error in type 类型错误
error 22: Structure too large 结构类型太长
error 23: Set base type out of range 集合基类型越界
error 24: File components may not be files or objectsfile 分量不能是文件或对象
error 25: Invalid string length 无效的字符串长度
error 26: Type mismatch 类型不匹配
error 27：error 27：Invalid subrange base type 无效的子界基类型
error 28：Lower bound greater than upper bound 下界超过上界
error 29：Ordinal type expected 缺有序类型
error 30：Integer constant expected 缺整型常量
error 31：Constant expected 缺常量
error 32：Integer or real constant expected 缺整型或实型常量
error 33：Pointer Type identifier expected 缺指针类型标识符
error 34：Invalid function result type 无效的函数结果类型
error 35：Label identifier expected 缺标号标识符
error 36：BEGIN expected 缺 BEGIN
error 37：END expected 缺 END
error 38：Integer expression expected 缺整型表达式
error 39：Ordinal expression expected 缺有序类型表达式
error 40：Boolean expression expected 缺布尔表达式
error 41：Operand types do not match 操作数类型不匹配

error 42：Error in expression 表达式错误
error 43：Illegal assignment 非法赋值
error 44：Field identifier expected 缺域标识符
error 45：Object file too large 目标文件太大
error 46：Undefined external 未定义的外部过程与函数
error 47：Invalid object file record 无效的 OBJ 文件格式
error 48：Code segment too large 代码段太长
error 49：Data segment too large 数据段太长
error 50：DO expected 缺 DO
error 51：Invalid PUBLIC definition 无效的 PUBLIC 定义
error 52：Invalid EXTRN definition 无效的 EXTRN 定义
error 53: Too many EXTRN definitions 太多的 EXTRN 定义
error 54：OF expected 缺 OF
error 55：INTERFACE expected 缺 INTERFACE
error 56：Invalid relocatable reference 无效的可重定位引用
error 57：THEN expected 缺 THEN
error 58：TO or DOWNTO expected 缺 TO 或 DOWNTO
error 59：Undefined forward 提前引用未经定义的说明
error 61：Invalid typecast 无效的类型转换
error 62：Division by zero 被零除
error 63：Invalid file type 无效的文件类型

error 64：Cannot read or write variables of this type 不能读写此类型变量
error 65：Pointer variable expected 缺指针类型变量
error 66：String variable expected 缺字符串变量
error 67：String expression expected 缺字符串表达式
error 68：Circular unit reference 单元 UNIT 部件循环引用
error 69：Unit name mismatch 单元名不匹配
error 70：Unit version mismatch 单元版本不匹配
error 71：Internal stack overflow 内部堆栈溢出
error 72：Unit file format error 单元文件格式错误
error 73：IMPLEMENTATION expected 缺 IMPLEMENTATION
error 74：Constant and case types do not match 常量和 CASE 类型不匹配
error 75：Record or object variable expected 缺记录或对象变量
error 76：Constant out of range 常量越界
error 77：File variable expected 缺文件变量
error 78：Pointer expression expected 缺指针表达式
error 79：Integer or real expression expected 缺整型或实型表达式
error 80：Label not within current block 标号不在当前块内
error 81：Label already defined 标号已定义
error 82：Undefined label in preceding statement part 在前面未定义标号
error 83：Invalid @ argument 无效的@参数
error 84：UNIT expected 缺 UNIT
博学谷——让 IT 教学更简单，让 IT 学习更有效
5
error 85: ";" expected 缺“；”
error 86： ":" expected 缺“：”
error 87： "," expected 缺“，”
error 88： "(" expected 缺“（”
error 89： ")" expected 缺“）”
error 90： "=" expected 缺“=”
error 91： ":=" expected 缺“:=”
error 92： "[" or "(." Expected 缺“[”或“（.”
error 93: "]" or ".)" expected 缺“］”或“.）”
error 94： "." expected 缺“.”
error 95: ".." expected 缺“..”
error 96：Too many variables 变量太多
error 97：Invalid FOR control variable 无效的 FOR 循环控制变量
error 98：Integer variable expected 缺整型变量
error 99：Files and procedure types are not allowed here 该处不允许文件和过程类型
error 100：String length mismatch 字符串长度不匹配
error 101：Invalid ordering of fields 无效域顺序
error 102：String constant expected 缺字符串常量
error 103：Integer or real variable expected 缺整型或实型变量
error 104：Ordinal variable expected 缺有序类型变量
error 105：INLINE error INLINE 错误
                                  
error 106：Character expression expected 缺字符表达式
error 107：Too many relocation items 重定位项太多
error 108：Overflow in arithmetic operation 算术运算溢出
error 112：CASE constant out of range CASE 常量越界
error 113：Error in statement 表达式错误
error 114：Cannot call an interrupt procedure 不能调用中断过程
error 116：Must be in 8087 mode to compile this 必须在 8087 模式编译
error 117：Target address not found 找不到目标地址
error 118：Include files are not allowed here 该处不允许 INCLUDE 文件
error 119：No inherited methods are accessible here 该处继承方法不可访问
error 121：Invalid qualifier 无效的限定符
error 122：Invalid variable reference 无效的变量引用
error 123：Too many symbols 符号太多
error 124：Statement part too large 语句体太长
error 126：Files must be var parameters 文件必须是变量形参
error 127：Too many conditional symbols 条件符号太多
error 128：Misplaced conditional directive 条件指令错位
error 129：ENDIF directive missing 缺 ENDIF 指令
error 130：Error in initial conditional defines 初始条件定义错误
error 131：Header does not match previous definition 和前面定义的过程或函数不匹配
error 133：Cannot evaluate this expression 不能计算该表达式

error 134：Expression incorrectly terminated 表达式错误结束
error 135：Invalid format specifier 无效格式说明符
error 136：Invalid indirect reference 无效的间接引用
error 137：Structured variables are not allowed here 该处不允许结构变量
error 138：Cannot evaluate without System unit 没有 System 单元不能计算
error 139：Cannot access this symbol 不能存取符号
error 140：Invalid floating point operation 无效的符号运算
error 141：Cannot compile overlays to memory 不能编译覆盖模块至内存
error 142：Pointer or procedural variable expected 缺指针或过程变量
error 143：Invalid procedure or function reference 无效的过程或函数调用
error 144：Cannot overlay this unit 不能覆盖该单元
error 146：File access denied 不允许文件访问
error 147：Object type expected 缺对象类型
error 148：Local object types are not allowed 不允许局部对象类型
error 149：VIRTUAL expected 缺 VIRTUAL
error 150: Method identifier expected 缺方法标识符
error 151：Virtual constructors are not allowed 不允许虚构造函数
error 152：Constructor identifier expected 缺构造函数标识符
error 153：Destructor identifier expected 缺析构函数标识符
error 154：Fail only allowed within constructors 只能在构造函数内使用 Fail 标准过程
error 155：Invalid combination of opcode and operands 操作数与操作符无效组合
error 156：Memory reference expected 缺内存引用指针
error 157：Cannot add or subtract relocatable symbols 不能加减可重定位符号
error 158：Invalid register combination 无效寄存器组合
error 159：286/287 instructions are not enabled 未激活 286/287 指令
error 160：Invalid symbol reference 无效符号指针
error 161：Code generation error 代码生成错误
error 162：ASM expected 缺 ASM
error 166：Procedure or function identifier expected 缺过程或函数标识符
error 167：Cannot export this symbol 不能输出该符号
error 168：Duplicate export name 外部文件名重复
error 169：Executable file header too large 可执行文件头太长
error 170：Too many
```

# 理解

```bash
.sync修饰符
两个div重叠
http请求：http请求头
有效的存储
手写排序
还有js 执行函数打印的顺序
怎么解决li 缝隙问题
爬楼梯
垂直居中
协商缓存，DNS缓存

手写ajax请求

数据类型
基本数据类型：Number、String、Boolean、Null、undefined、Symbol、BigInt
  存储在栈中，数据大小确定、可以直接操作保存在变量中的实际值
引用数据类型：object。引用地址存储在堆内存中，变量是保存的在栈内存中的一个指针，这个指针指向堆内存
  引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址

定位
1. 绝对定位：定位是相对于离自己最近设置了相对或绝对定位的父元素定位；
   若没有，则以浏览器窗口Body的左上角定位；绝对定位的元素会脱标，不占位置
2. 相对定位：相对于自身进行定位，元素仍然占据原来的位置
   当元素设置了transform属性，该元素会具备相对定位的特性
3. 固定定位：始终以浏览器窗口的可视区域定位，元素不占位置
4. 静态定位：元素的标准流显示方式，不可移动元素
5. 可通过z-index进行定位元素的上下层级移动(静态定位不能设置)

清除浮动
1. 给设置浮动元素标签最后面新增一个标签，并设置属性`clear:both;`    clear:both的本质是闭合浮动，让父盒子闭合出口和入口，不让子盒子出来
2. 给设置浮动的父级添加overflow属性
3. 给设置浮动的父元素中使用after伪元素清除浮动，在:after中添加设置模式为块元素，并通过clear:both清除浮动
4. 给设置浮动的父元素中使用before和after双伪元素清除浮动，设置模式为table元素，并在after中清除浮动
    注意：为了兼容ie浏览器，需要给父元素添加属性 *zoom: 1;

垂直居中的方式
1. flex布局：设置display:flex和align-item:center;
2. margin和transform配合，margin:50% auto，transform:translateY(-50%);
3. 设置模式为行内块和垂直居中属性：display:inline-block;vertical-align:middle;
4. 设置绝对定位和负margin：position:absolute;margin-left:-50%;margin:-50%;
5. 设置绝对定位和margin:auto；	当宽度和高度未知时使用
6. 设置绝对定位和transform：position:absolute;left:50%;right:50%; transform: translate(-50%, -50%)
7. 网格布局：设置display:grid;align-self:center

promise.any：只要一个成功就返回成功，如果所有的都是失败，则报错；如果any接收的是一个非promise数组，则返回成功
promise.race：看第一个执行完成的promise，且状态跟第一个执行完成的状态一致；一般用作超时处理
promise.all：所有执行成功才会返回成功，否则返回失败


vue2的数据双向绑定原理
1. 通过监听器Observer：劫持并监听对象所有属性，利用Object.definedProperty()对属性加上setter和getter方法
2. 通过解析器Compile：解析Vue模板指令，将模板的变量替换为数据，然后渲染页面视图，并对每个指令节点绑定更新函数，添加监听数据的订阅者，当数据有变动，就会调动更新函数进行数据更新
3. 订阅者Watcher：是监听器和解析器之间通信的桥梁，主要是订阅监听器中的属性值变化，当发生变化，就会触发解析器中对应的更新函数
4. 订阅器Dep：订阅器采用 发布-订阅 模式，用来收集订阅者，对监听器和解析器进行统一管理。

v-show与v-if的区别 ？ 
   v-show：初始渲染高，等同display:none，适用于频繁切换的；
   v-if：按条件渲染，每次都删除或创建元素，适用于运行时很少改变条件的
computed与watch的区别?
   computed：依赖其他属性值，并且computed有缓存，只有依赖值发生改变，下一次获取才会改变； 会产生一个新的属性值
   watch：监听其他数据的变化，并且监听的值必须存在data中，不支持缓存，每当数据变化后回调执行
父子组件生命周期
  父beforeCreate->父created->父beforeMounted->子beforeCreate->子created->子beforeMount->子mounted->父mounted
组件生命周期
  beforeCreated：vue实例的el挂载元素和数据对象data都是undefined，还未初始化
  created：vue实例的数据data加载，但是挂载元素el还没初始化
  beforeMounted：挂载元素已经初始化，但是还没挂载前都是虚拟的demo阶段，data和message还未替换
  mounted：vue实例挂载完成，data中的数据渲染到页面上
  当data数据发生变化时，触发beforeUpdate和updated
组件间的通信
   1. props / $emit 适用父子组件通信
   2. ref 与 $parent / $children 适用于父子组件通信
   3. 事件总线 适用于父子、隔代、兄弟组件通信
   4. $attrs / $listeners 适用于隔代组件通信
   5. provide / inject 适用于隔代组件通信
   6. Vuex 适用于父子、隔代、兄弟组件通信


全局变量实现的方式
1. vuex
2. 通过module.exports：可在一个js文件中定义变量，然后通过module.exports暴露出去，最后通过入口文件全局挂载到Vue.protype中；通过this来进行引用
3. 通过export default：可在一个js文件中定义变量，然后通过export default暴露出去，最后通过入口文件全局挂载到Vue.protype中；通过this来进行引用

vue的key值使用场景
1. v-for：key是虚拟DOM对象的表示。在数据发生变化时，新旧虚拟DOM会根据diff算法对比，若kye值找到，就判断数据是否相同；key值不同，则创建一个
   所以一般不用索引下标来当做key值，因为Key值很容易相同，但是内容不同
2. 动态路由中添加key，管理可复用元素：Vue会尽可能高效的渲染元素，通常会复用已有元素，但此时会带来一些不好的副作用，所以通过key来辨识他们不一样
 主要作用是为了高效的更新虚拟DOM，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素




跨域与jsonp
0. JOSNP是什么？
  JSONP是一种非正式传输协议，主要利用script标签没有跨域限制的漏洞来解决跨域通信，
   该协议允许用户传递一个回调参数给服务器，然后服务器返回数据时会将这个callback参数作为函数名包裹JSON数据
     <script>
         function callfun(data) { document.getElementById('qwerty').innerHTML = data; }
     </script>
     <script src="http://127.0.0.1:10010/js?call=callfun"></script>
1. 什么叫跨域？
   跨越域名，通常两个域名不同会无法进行通信，浏览器会采用同源策略对其限制
2. 什么同源？
  同源是指“协议、域名、端口号”相同，
  同源是为了保护用户信息的安全，防止恶意网站窃取数据，确保一个应用中的资源只能被本应用访问
3. 同源的限制
   cookie、localstorage、indexDB无法读取，DOM无法获得，AJAX请求不能发送


输入url到页面加载完成的过程
1. 解析url，包括url的协议、域名、端口号、路径、参数以及哈希值
2. 解析DNS
3. 
```



# 试题

## 概念题

### 盒子模型

- CSS 的盒子模型有两种：标准W3C盒子模型模型、IE盒子模型(怪异盒模型)；本质是盒子，封装周围的HTML元素。

- 盒模型 = 内容(content)、填充(padding)、边界(margin)、边框(border)

- > 注意：IE盒子模型的content部分包含了border和pad  ding

- 两种盒子模型的样式兼容性问题：建议不要给元素添加具有指定宽度的内边距，而是将内边距或外边距添加到元素的父元素和子元素

- **`box-sizing` 属性**：指定盒子模型种类，`content-box`指定盒子模型为标准盒模型，`border-box`为怪异盒模型

```css
box-sizing: content-box;//宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。

box-sizing: border-box;// 为元素设定的宽度和高度决定了元素的边框盒。即为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制；通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。

box-sizing: inherit;// 规定应从父元素继承 box-sizing 属性的值。
```

![image-20211015145858102](image/image-20211015145858102.png)

### callback，Promise，async&await三者区别

- callback 经过深层次的嵌套，会产生回调地狱，需手动检查err参数
- promise 通过链式调用，直接在 then 中返回一个 promise 来进行成功之后的回调函数，用 catch 来做错误处理
- async/await 则直接将其变成了同步的写法，既可以用.catch又可以用try-catch捕捉，简洁，可读性强
- **注意：try…catch只能捕获同步函数的异常，不可以捕获promise异常**

### http1和http2

- http1.0 exprires last-modified 连接无法复用
  http1.1 etag cache-control 支持长连接（connection） 支持文件断点续传
  http2.0 多路复用 首部压缩 server push 传输速度更快了

```js
http1.0
仅支持保持短暂的TCP链接
不追踪ip

http1.1
支持长连接
纯文本报头
增加了更多的请求头和响应头
连接数过多 容易队首阻塞 且串行传输

http2.0
多路复用，并行请求
二进制报头 数据帧：HTTP2.0 会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码首部压缩服务器端推送
对报头压缩，降低开销
服务器主动推送，减少请求延迟
默认使用加密 增加伪头字段
```

### http和https

```js
https 协议的工作原理 客户端在使用 https 方式与 web 服务器通信时有以下几个步骤：
  客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。
  web 服务器接收到客户端的请求之后，会将网站的证书(证书中包含了公钥)，返回或者说传输给客户端。
  客户端和 web 服务器端开始协商 ssl 链接的安全等级，也就是加密等级。
  客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传输给网站。
  web 服务器通过自己的私钥解密出会话密钥。
  服务器通过会话密钥加密与客户端之间的通信。
  
https 协议的优点
使用 https 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。
https 协议是由 ssl+http 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
https 是现行架构下最安全的解决方案，虽然不是绝对安全，但是它大幅增加了中间人攻击的成本。

https 协议的缺点
https 握手比较费时，会使页面加载时间延长 50%，增加 10%~20% 的耗电。
https 缓存不如 http 高效，会增加数据开销。
ssl 证书也需要钱，功能越强大的证书费用越高。
ssl 证书需要绑定 ip，不能同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗
```

### TCP四次挥手

- 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

  TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
  服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
  服务器关闭客户端的连接，发送一个FIN给客户端。
  客户端发回ACK报文确认，并将确认序号设置为收到序号加1。

![image-20211025153149658](image/image-20211025153149658.png)

### WebSocket 的实现和应用

什么是WebSocket? WebSocket 是HTML5 中的协议，支持持久连续，http 协议不支持持久性连接。Http1.0 和HTTP1.1 都不支持持久性的链接，HTTP1.1 中的keep-alive，将多个http 请求合并为 1 个。

WebSocket 是什么样的协议，具体有什么优点？ HTTP 的生命周期通过Request 来界定，也就是Request 一个Response，那么在Http1.0 协议中，这次Http 请求就结束了。在Http1.1 中进行了改进，是的有一个connection： Keep-alive，也就是说，在一个Http 连接中，可以发送多个Request，接收多个Response。 但是必须记住，在Http 中一个Request 只能对应有一个Response，而且这个Response 是被动的，不能主动发起。

WebSocket 是基于Http 协议的，或者说借用了Http 协议来完成一部分握手，在握手阶段 与Http 是相同的。我们来看一个websocket 握手协议的实现，基本是2 个属性，upgrade， connection。

### cookie、localstorage、sessionstorage的区别

```js
cookie 和session 的区别，localstorage 和sessionstorage 的区别
参考回答： Cookie、sessionStorage、localStorage共同点：都是保存在浏览器端，并且是同源的。

Cookie和session： Cookie 和session 都可用来存储用户信息，cookie 存放于客户端，session 存放于服务器端，因为cookie 存放于客户端有可能被窃取，所以cookie 一般用来存放不敏感的信息，比如用户设置的网站主题，敏感的信息用session 存储，比如用户的登陆信息，session 可以存放于文件，数据库，内存中都可以，cookie 可以服务器端响应的时候设置，也可以客户端通过JS 设置cookie 会在请求时在http 首部发送给客户端，cookie 一般在客户端有大小限制，一般为4K，很多浏览器都限制一个站点最多保存20 个cookie。

cookie 有哪些编码方式？encodeURI（）
cookie 的作用： 保存用户登录状态。例如将用户id 存储于一个cookie 内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。cookie 还可以设置过期时间，当超过时间期限后，cookie 就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个月、一年等。跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie 后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie 来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。

sessionStorage： 仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，
localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；
cookie 只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session 为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）。

localStorage 和 cookie 在所有同源窗口中都是共享的（key：同源窗口都会共享并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）

下面从几个方向区分一下cookie，localstorage，sessionstorage 的区别
1、生命周期：
Cookie：可设置失效时间，否则默认为关闭浏览器后失效
Localstorage:除非被手动清除，否则永久保存
Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除
2、存放数据：
Cookie：4k 左右
Localstorage 和sessionstorage：可以保存5M 的信息
3、http 请求：
Cookie：每次都会携带在http 头中，如果使用cookie 保存过多数据会带来性能问题
其他两个：仅在客户端即浏览器中保存，不参与和服务器的通信
4、易用性：
Cookie：需要程序员自己封装，原生的cookie 接口不友好
其他两个：即可采用原生接口，亦可再次封装
5、应用场景：
从安全性来说，因为每次http 请求都回携带cookie 信息，这样子浪费了带宽，所以cookie应该尽可能的少用，此外cookie 还需要指定作用域，不可以跨域调用，限制很多，但是用户识别用户登陆来说，cookie 还是比storage 好用，其他情况下可以用storage，localstorage可以用来在页面传递参数，sessionstorage 可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。

说一下web worker
参考回答： 在HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的js，独立于其他脚本，不会影响页面你的性能。并且通过postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 如何创建web worker：检测浏览器对于web worker 的支持性，创建web worker 文件（js，回传函数等），创建web worker 对象。
```

```js
HTML5 和CSS3 用的多吗？你了解它们的新属性吗？有在项目中用过吗？
html5：
8 个语义元素header section footer aside nav main article figure
内容元素mark 高亮progress 进度
新的表单控件calander date time email url search
新的input 类型color date datetime datetime-local email
移除过时标签big font frame frameset
canvas 绘图，支持内联SVG。支持MathML
多媒体audio video source embed track
本地离线存储，把需要离线存储在本地的文件列在一个manifest 配置文件
web 存储。localStorage、SessionStorage
css3：
CSS3 边框如border-radius，box-shadow等；
CSS3 背景如background-size，background-origin等；
CSS3 2D，3D 转换如transform 等；
CSS3 动画如animation 等。
```

### DNS

- DNS(Domain Name System)域名系统，即根据服务器根据域名的层级来查找IP地址。
- `主机名.次级域名.顶级域名.根域名`
- 解析过程
  - 从"根域名服务器"查到"顶级域名服务器"的NS记录和A记录（IP地址）
  2. 从"顶级域名服务器"查到"次级域名服务器"的NS记录和A记录（IP地址）
  3. 从"次级域名服务器"查出"主机名"的IP地址

### new生成一个对象的过程

​	以 var p=new ClassA( ) 为列

1. 创建空对象；`  var p= {};`
2. 设置新对象的__proto__属性指向构造函数的prototype对象；` p.__proto__ = ClassA.prototype;`
3. 使用新对象调用内部函数call，函数中的this被指向新实例对象：`ClassA.call(p);`　　
4. 将初始化完毕的新对象地址，保存到等号左边的变量中。
   - 注意： 正常来讲构造函数中是不用写return语句的，因为它会默认返回新创建的对象。但是如果在构造函数中写了return语句而且return的是一个对象，那么函数就会覆盖掉新创建的对象，而返回此对象；如果return的是基本类型如字符串、数字、布尔值等，那么函数会忽略掉return语句，还是返回新创建的对象。

### 事件

-  事件捕获：是从document到触发事件的那个节点，即自上而下的去触发事件

- 事件冒泡：IE提出的事件流，和事件捕获相反，即事件开始时由**最具体的元素接收，然后逐级向上传播到较为不具体的节点，是由下而上的去触发事件**

- **事件委托：事件委托是利用事件冒泡，只指定一个事件处理程序来管理某一类型的所有事件。**

- **为什么要用事件委托？**

    1.在JavaScript中添加到页面上的事件处理程序的个数直接关系到页面的整体运行性能。为什么呢？因为，每个事件处理函数都是对象，对象会占用内存，内存中的对象越多，性能就越差。此外，必须事先指定所有的事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。

    2.对有很多个数据的表格以及很长的列表逐个添加事件，简直就是噩梦。所以事件委托，能极大地提高页面的运行性能，减少开发人员的工作量。

### vue

```js
对vue的理解
Vue 是一个构建数据驱动的渐进性框架，它的目标是通过API 实现响应数据绑定和视图更新。 
优点：
数据驱动视图，对真实dom 进行抽象出virtual dom（本质就是一个js对象），并配合diff 算法、响应式和观察者、异步队列等手段以最小代价更新dom，渲染页面。
组件化，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文件里编写html\css（scoped 属性配置css 隔离）\js 并且配合Vue-loader 之后，支持更强大的预处理器等功能。
由于采用虚拟dom，让Vue ssr 先天就足，强大且丰富的API 提供一系列的api 能满足业务开发中各类需求。
生命周期钩子函数，选项式的代码组织方式，写熟了还是蛮顺畅的，但仍然有优化空间（Vue3 composition-api）
缺点：
由于底层基于Object.defineProperty（vue3.0采用 new Proxy()） 实现响应式，而这个api 本身不支持IE8及以下浏览器
csr 的先天不足，首屏性能问题（白屏）
由于百度等搜索引擎爬虫无法爬取js 中的内容，故spa 先天就对seo 优化心有余力不足（谷歌的puppeteer 就挺牛逼的，实现预渲染底层也是用到了这个工具）

什么是虚拟DOM？
虚拟dom 是相对于浏览器所渲染出来的真实dom 的，在react，vue 等技术出现之前， 我们要改变页面展示的内容只能通过遍历查询dom 树的方式找到需要修改的dom 然 后修改样式行为或者结构，来达到更新ui 的目的。 这种方式相当消耗计算资源，因为每次查询dom 几乎都需要遍历整颗dom 树，如果 建立一个与dom 树对应的虚拟dom 对象（ js 对象），以对象嵌套的方式来表示dom 树，那么每次dom 的更改就变成了js 对象的属性的更改，这样一来就能查找js 对象 的属性变化要比查询dom 树的性能开销小

Vue 双向绑定原理
Vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)。
Vue3.0采用了 new Proxy() 。


watch 和计算属性有什么区别？
通俗来讲，既能用computed 实现又可以用watch 监听来实现的功能，推荐用computed， 重点在于computed 的缓存功能
computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变；
watch 监听的是已经在data 中定义的变量，当该变量变化时，会触发watch 中的方法。


说一下axios怎么用？ 怎么解决跨域的问题？
axios 的是一种异步请求，用法和ajax 类似，安装npm install axios --save 即可使用，请求中包括get,post,put, patch ,delete 等五种请求方式，解决跨域可以在请求头中添加 Access-Control-Allow-Origin，也可以在index.js 文件中更改proxyTable 配置等解决跨域问题。


渲染一个列表时，何为key？设置key 的目的是什么
Keys 会有助于React 识别哪些items 改变了，被添加了或者被移除了。Keys 应该被赋 予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个key 的最佳方法是使用一 个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的IDs 作为 keys，当你没有稳定的IDs 用于被渲染的items 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果items 可以重新排序，就会导致re-render 变慢
```

```js
vue项目中全局配置变量
在项目中api管理需要用到全局变量,创建全局变量的方式也有很多。

1.通过export default
　　const BASEURL = "http://localhost:3333/"
　　const URL = {
　　　　getCategory:BASEURL+'category',
　　　　getGoodsInfo:BASEURL+'getGoodsInfo'
　　}
　　export default URL

　　在入口文件中引入
　　import url from './api/api'
　　Vue.prototype.URL=url;

2.通过module.exports
const BASEURL = "http://localhost:3333/"
const URL = {
  getCategory:BASEURL+'category',
  getGoodsInfo:BASEURL+'getGoodsInfo'
}
module.exports = URL;

在入口文件中引入Vue.prototype.URL=require('./api/api.js');
其实以上两种都是Vue.prototype原型引入；

3.通过node.js的global全局变量
global.apiBase={}
apiBase.baseUrl='http://localhost:3333/'

apiBase.getBanner="/banners"
apiBase.getcategory="/category"

export default {
　　apiBase
};

在路口文件中直接引入
import  ApiBase from './api/api'

4.通过VUEX的状态管理
　  import Vue from 'vue';
　　 import Vuex from 'vuex';Vue.use(Vuex);
   const state = {}
　　直接定义在state状态里面

5.通过window对象设置
```



## 提问题

### 对跨域了解吗，jsonp 的限制

> Q:为什么要跨域
> A:跨域，通常情况下是说在两个不通过的域名下面无法进行正常的通信，或者说是无法获取其他域名下面的数据，这个主要的原因是，浏览器出于安全问题的考虑，采用了同源策略，通过浏览器对JS的限制，防止恶意用户获取非法的数据。
>
> Q:同源策略
> A:限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制(降低XSS/CSFR等攻击)，是浏览器最核心最基本的安全功能
>
> Q:“同源”
> A:同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源
>
> Q:同源政策的目的
> A:是为了保证用户信息的安全，防止恶意的网站窃取数据，确保一个应用中的资源只能被本应用的资源访问。
>
> Q:同源的限制范围
> A:Cookie、LocalStorage 和 IndexDB 无法读取；DOM 无法获得；AJAX 请求不能发送
>
> **解决办法**
> 1.**只支持GET请求而不支持POST等其它类型的HTTP请求**（虽然采用post+动态生成iframe是可以达到post 跨域的目的，但这样做是一个比较极端的方式，不建议采用）。明确说明：jquery使用POST请求jsonp可以成功是由于jquery自动把POST转化成GET，实际还是GET请求
> 2.一般get请求能完成所有功能。如：如果需要给其他域服务器传送参数可以在请求后挂参数（注意不要挂隐私数据），即`<script src="http://xxx/getPerson.php?name=Hello&age=18"></script>`
> 3.JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。
> 4.在受信任的双方传递数据，JSONP是非常合适的选择。
> 5.可以看出来JSONP跨域一般用于获取其他域的数据。
> 6.一般能够用JSONP实现跨域就用JSONP实现，这也是前端用的最多的跨域方法。

### 浏览器哪些地方用到了异步

> JS是一门脚本语言，他的执行顺序是从上到下逐行执行的，浏览器只有一个javascript引擎，所以浏览器同时只能执行一个任务，那么异步操作的实现原理是什么呢？
> 浏览器的javascript引擎确实是单线程的，但是浏览器本身是多线程的，浏览器包含
> ***javascript引擎线程、界面渲染线程、浏览器事件触发线程、Http请求线程***
> 所以触发异步操作时，会有单独的线程去做操作，javascript引擎线程不会受到阻塞，依然继续解析js代码。
> **浏览器用到异步的地方是：promise的回调函数、定时器和计时器的回调函数、process.nextTick**
>
> 1. 不同的任务源会被分配到不同的`Task`队列中，任务源分为微任务(task)和宏任务(jobs)
> 2. 首先***执行同步代码***，这属于宏任务(`script、setTimeout、setInterval、setImmediate、I/O、UI rendering`)
> 3. 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
> 4.  ***执行所有微任务***(`process.nextTick、promise、MutationObserver`)
> 5. 当执行完所有微任务后，如有必要，会渲染页面
> 6. 然后开始下一轮`Event Loop`，***执行宏任务的异步代码***，即`setTimeout、setInterval`中的回调函数

### setTimeout的运行机制

>在现有浏览器环境中，Javascript执行引擎是单线程的，主线程的语句和方法会阻塞定时任务的运行，在Javascript执行引擎之外，存在一个任务队列，当在代码中调用setTimeout()方法时，注册的延时方法会挂到浏览器内核其他模块处理，当延时方法到达触发条件，即到达设置的延时时间时，该模块再将要执行的方法添加至该模块的任务队列中。这一过程与执行引擎主线程独立，执行引擎在主线程方法执行完毕，到达空闲状态时，才会从该模块的任务队列中顺序提取任务来执行，这期间的时间，可能大于注册任务时设置的延时时间；
>浏览器在空闲状态下，会不断的尝试从模块的任务队列中提取任务，这称为事件循环模型；

### vue

> - **vue的特点**
>   - 数据双向绑定，数据响应式改变
>   - 组件化开发，使得代码量减少
>   - vue内置指令：可以达到对页面效果处理的行为
>   - 客户端路由；相对于传统的页面通过超链接实现页面的切换和跳转，vue路由不会刷新页面
>   - vuex状态管理，减少对数据的重复性定义和处理

### 从输入URL到页面展示的过程

> 1. **DNS查询**
>    1. 浏览器首先搜索浏览器自身缓存的DNS记录
>    2. 如果浏览器缓存中没有找到需要的记录或记录已过期，则搜索hosts文件和操作系统缓存
>    3. 如果在hosts文件和操作系统缓存中没有需要的记录或记录已过期，则向域名解析服务器发送解析请求
>    4. 如果域名解析服务器也没有该域名的记录，则开始递归+迭代解析
>    5. 获取域名对应的IP后，一步步向上返回，直到返回给浏览器
> 2. **发起TCP三次握手**
>    1. 第一次握手：建立连接时，客户端向服务端发送请求报文
>    2. 第二次握手：服务器收到报文后，如果同意连接，则向客户端发送确认报文
>    3. 第三次握手：客户端收到服务器的确认后，再次向服务器给出确认报文，完成连接
> 3. **浏览器向web服务器发送http请求**
>    - 请求行：指定http请求的方法、url、http协议版本等
>    - 请求头：描述浏览器的相关信息，如语言、编码等
>    - 请求正文：当发送POST、PUT请求时，通常需要向服务器传递数据，这些数据就储存在请求正文中
> 4. **服务器处理HTTP请求，并返回响应报文**(状态码、响应头、响应正文)
>    - 响应头：包含了响应的相关信息，如日期等
>    - 响应正文：服务器返回给浏览器的文本信息，通常html、js、css和图片等就包含在里面
> 5. **浏览器页面渲染**
>    - 浏览器接受到http服务器发送过来的响应报文，并开始解析html文档，渲染页面。
>    - 具体渲染过程包括：构建DOM树、构建渲染树、定位页面元素、绘制页面元素等

### TCP和UDP的区别

> - TCP是面向连接，UDP是面向无连接的（即发送数据前不需要简历连接）
> - TCP提供可靠的服务；通过TCP连接传送的数据，无差错，不丢失，不重复，且按需到达；UDP尽最大努力交付，即不保证可靠交付；因TCP可靠、面向连接且不会丢失数据，因此不适合大数据量的交换。
> - TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，所以常用于实时的应用，如IP电话和视屏会议等）
> - TCP只能1对1，UDP支持1对1和1对多
> - TCP的首部较大为20字节，而UDP只有8字节
> - TCP是面向连接的可靠传输，而UDP是不可靠的
> - **TCP是可靠传输的原因**：数据报校验, 失序数据重排序, 丢弃重复数据,应答机制,超时重发,流量控制等

### TCP三次握手

> - 客户端和服务端都需要各自收发，因此需要三次握手（C 发起请求连接S 确认，也发起连接C）
> - 第一次握手：S 只可以确认自己可以接受C 发送的报文段
>   第二次握手：C 可以确认S 收到了自己发送的报文段，并且可以确认自己可以接受S 发送的报文段。
>   第三次握手：S 可以确认C 收到了自己发送的报文段。
>
> ![image-20211025152552031](image/image-20211025152552031.png)

### http和https的区别

> - 综述：http 传输的数据都是明文(未加密)，网景公司设置了 ssl 协议来对 http 协议传输的数据进行加密处理，简单来说 https 协议是由 http 和 ssl 协议构建的可进行加密传输和身份认证的网络协议，比 http 协议的安全性更高。
> - https 协议需要 ca 证书，费用较高。
> - http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。
> - http 协议的端口为80，https 的端口为443.
> - http 的链接是无状态的；https 协议是由 ssl+http 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

### FTP协议

>- FTP允许用户以文件操作的方式(如文件的增、删、改、查、传送等)与另一主机相互通信。然而，用户并不真正登录到自己想要存取的计算机上面而成为完全用户，可用FTP程序访问远程资源，实现用户往返传输文件、目录管理以及访问电子邮件等，即是双方计算机可能配有不同的操作系统和文件存储方式。
>- FTP是应用层的一个文件传输协议，使用了两个并行的TCP来传输文件，一个是**控制连接(21端口)**，一个是**数据连接(20端口)** 
>  在介绍FTP的工作原理时候，通常会讲到两个信道(控制信道、数据信道)和两种模式(主动模式、被动模式)
>- **控制信道和数据信道**：
>  - 控制信道是创建会话的必要条件,通常传输控制信息，如口令，用户标识，存放、获取文件等命令
>  - 数据信道则是临时创立的，它通常被用来传输文件。当发送完文件之后数据连接会自动关闭
>- **主动模式(服务器主动发起请求)**：
>  - 控制信道：客户端(端口随机) -----> 服务器21端口
>  - 数据信道：客户端(端口随机) <----- 服务器20端口
>  - 在主动模式下，客户端向服务器的FTP端口21发起连接请求，服务器接收连接后，创建一条命令链路。当需要传输数据时，客户端在链路上用PORT命令告诉服务器:"我打开了X端口，需要你连接我"。接着服务器从20端口向客户端的X端口发起连接请求，之后双方可以利用数据通道来传输数据
>- **被动模式(服务器被动响应请求):**
>  - 控制信道：客户端(端口随机) -----> 服务器21端口
>  - 数据信道：客户端(端口随机) <----- 服务器随机端口
>  - 被动模式下控制信道的传输方式和主动一致，但是在需要数据传输的时候，服务器在控制信道上用PASV的命令告诉客户端，我开启了XX端口，你过来连接我，之后服务器被动等待客户端连接它的XX端口，创建连接后开始传输数据
>- 在创建连接的过程中，有很多FTP独有的命令。例如在被动模式下的控制信道，经过三次握手后，客户端会向服务器发送PASV命令，意为：你是否支持被动模式，服务器如果支持则会返回227:a,b,c,d,e,f。其中a,b,c,d为IP地址。端口为e*256+f，到了第二信道，双方的通信端口都是随机的，这样较为安全。
>- 当有防火墙的时候，需要转换IP端口，防火墙做了什么？

## 编程题

### 回文判断

- 回文是倒转仍然等于原来的字符串

```js
// split() 把字符串转为数组; reverse() 把数组颠倒过来; join()把数组转为字符串
fn = (v) => v == v.split('').reverse().join('')
console.log(fn('manam'))
```

### var定义函数问题

```js
/* 循环中使用闭包解决 var 定义函数的问题 */
for (var i = 1; i <= 5; i++) {
   setTimeout(function timer() {
      console.log(i)
   }, i * 1000)
}
console.log(i); // 先输出（因为i是用var定义，所以存在变量提升）
/* 输出： 第 1 个 3 直接输出，1 秒之后，连续输出 3 个 3
分析：for循环是同步任务，setTimeout是异步任务；
      for循环每次遍历时遇到setTimeout都会先暂留着往后处理；
      等for循环处理完成(此时 i 已为3 )，再处理异步任务(定时器)。
      循环执行过程中，几乎同时设置了3个定时器，这些定时器都会在 1 秒后触发，而循环的输出是立即执行的 */

/* 1. 使用闭包 */
for (var i = 1; i <= 5; i++) {
   (function (j) {
      setTimeout(function timer() {
         console.log(j)
      }, j * 1000)
   })(i)
}

/* 2. 通过定时器的第三个参数（会被当成timer函数的参数传入） */
for (var i = 1; i <= 5; i++) {
   setTimeout(function timer(j) {
      console.log(j)
   }, i * 1000, i)
}

/* 3. 使用 let 定义 i */
for (let i = 1; i <= 5; i++) {
   setTimeout(function timer() {
      console.log(i)
   }, i * 1000)
}
```

### 数字位数固定补零

```js
const addZero1 = (num, len = 2) => (`0${num}`).slice(-len);
const addZero2 = (num, len = 2) => (`${num}`).padStart(len, '0');
addZero1(3);  // 03
addZero2(32, 4);  // 0032
```

```js
formatZero = (num, len) => {
  if (String(num).length > len) return num;
  return (Array(len).join(0) + num).slice(-len);
}
let a = formatZero(123456, 5);
let b = formatZero(123, 5);
console.log(a,b); // 123456 '00123'
```

### id自增

**闭包实现id自增**

```js
function next_id(){
    var current_id = 0;
    return function (){
        return ++current_id;
    }
}
var g =  next_id();
for( let i = 0; i < 10; i++ ){
    console.log(g());
}
```

**迭代器generator实现id自增**

```js
function* next_id(){
    let current_id =0;
    while(true) {
        current_id++;
        yield current_id;
    }
}

let g = next_id();

for( var i = 0; i < 10; i++ ){
    console.log( g.next().value )
}
```

### 数组去重

> ```js
> let arr = [1, 0, 0, 2, 9, 8, 3, 1];
> arr1 = Array.from(new Set(arr))
> arr2 = [...new Set(arr)]
> arr3 = arr.filter((n, i) => arr.indexOf(n) === i )	// 判断这个不重复数的下标是否跟是当前数的下标一致，一致则认为该数是第一次出现，则存入新数组；不一致则说明该数非第一次出现，跳过
> arr4 = arr.sort().filter((n, i) => n != arr[i+1] )	// 先排序，然后判断前后两个数是否相同，不同则存到新数组里面
> arr5 = arr.reduce((acc, n, i) => [].concat(acc, arr.indexOf(n) === i ? n : []))
> ```

###  统计相同项的个数

```js
// 统计相同项的个数
let cars = ['BMW','Benz',  'Benz',  'Tesla',  'BMW',  'Toyota'];
let carsObjNum = cars.reduce((objNum, name) => {
  objNum[name] = objNum[name] ? ++objNum[name] : 1
  return objNum
}, {})
console.log(carsObjNum);  // { BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 }
```

### 合并数组并排序

- **把俩个数组` [A1, A2, B1, B2, C1, C2, D1, D2]` 和` [A, B, C, D]`，合并为 `[A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]`**

```js
let a1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']
// 先给['A', 'B', 'C', 'D']数组添加标记 
let a2 = ['A', 'B', 'C', 'D'].map((item) => item + 'flag' )
/* 先排序，然后删除标记 */
let a3 = [...a1, ...a2].sort().map((item) => {
  if (item.includes('flag')) {
    return item.split('')[0]
  }
  return item
})
console.log(a3);
```

### 隐式转换

- 问当a等于什么时，`if (a == 1 && a == 2 && a == 3) { console.log(1); }`恒成立

````js
/* 当a为对象时 */
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
}
if (a == 1 && a == 2 && a == 3) { console.log(1); }
````

```js
/* 当a为数组时 */
var a = [1, 2, 3];
a.join = a.shift;
if (a == 1 && a == 2 && a == 3) { console.log('1'); }
```

```js
/* 当a为es6的symbol时 */
let a = { 
  [Symbol.toPrimitive]: ((i) => () => ++i)(0) 
};
if (a == 1 && a == 2 && a == 3) { console.log('1'); }
```

### 随机数

**随机生成一个长度为 10 的整数类型的数组，例如 `[2, 10, 3, 4, 5, 11, 10, 11, 20]`，将其排列成一个新数组，要求新数组形式如下，例如 `[[2, 3, 4, 5], [10, 11], [20]]`**

```js
// 得到一个两数之间的随机整数，包括两个数在内
function getRandomIntInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
// 随机生成10个整数数组, 排序, 去重
let initArr = Array.from({ length: 10 }, (v) => getRandomIntInclusive(0, 99));
initArr.sort((a, b) => a - b);
initArr = [...new Set(initArr)];

// 放入hash表
let obj = {};
initArr.map((i) => {
  const intNum = Math.floor(i / 10);
  if (!obj[intNum]) obj[intNum] = [];
  obj[intNum].push(i);
})

const resArr = [];
for (let i in obj) {
  resArr.push(obj[i]);
}
console.log(resArr);
```

### 旋转数组

```js
function rotate(arr, k) {
  const len = arr.length
  const step = k % len
  return arr.slice(-step).concat(arr.slice(0, len - step))
}
rotate([1, 2, 3, 4, 5, 6], 7) // => [6, 1, 2, 3, 4, 5]
```

### 字符串大小写取反

```js
function processString(str) {
  let arr = str.split('').map(item => item === item.toUpperCase() ? item.toLowerCase() : item.toUpperCase());
  str = arr.join('');
  return str;
}
console.log(processString('Abc'));  // aBC
```

### 不定长参柯里化函数

```js
function add() {
  let args = [].slice.call(arguments);
  let fn = function () {
    let fn_args = [].slice.call(arguments)
    return add.apply(null, args.concat(fn_args))
  }
  fn.toString = function () {
    return args.reduce((a, b) => a + b)
  }
  return fn
}

let a = add(1); 			// 1
let b = add(1)(2);  	// 3
let c = add(1)(2)(3) // 6
let d = add(1)(2, 3); // 6
let f = add(1, 2)(3); // 6
let e = add(1, 2, 3); // 6
console.log(a, b, c, d, e, f);
```





## 逻辑题

### 青蛙跳台阶

**一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法**

1. 原理为使用了斐波那契数列；
2. 当台阶超过三级时，青蛙跳一次台阶有两种跳法；
3. 如果跳1级，则在`(n-1)`级阶梯上跳1级，则有`f(n-1)`种跳法；
4. 如果跳2级，则在`(n-2)`级阶梯上跳2级；
5. 所以该次跳台阶有`f(n) = f(n-1) + f(n-2)`种跳法
   （即当台阶超过3级时跳一次台阶，需要计算(n-1)级的跳法 和 (n-2)级的跳法）

```js
// 有 n 个台阶，你可以选择每次完成一个台阶 或者 两个台阶，试问走完这 n 个台阶有多少种走法
function jumpFloor(n) {
  if (n == 1) return 1;
  else if (n == 2) return 2;
  else if (n >= 3) {
    const arr = [];
    arr[1] = 1, arr[2] = 2;
    for (i = 3; i <= n; i++) {
      // 计算(n-1)级的跳法 和 (n-2)级的跳法
      arr[i] = arr[i - 1] + arr[i - 2];
    }
    return arr[n]
  }
}
console.log(jumpFloor(10)); // 89
```

**一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法？**

- 因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级
  跳1级，剩下n-1级，则剩下跳法是f(n-1)；
  跳2级，剩下n-2级，则剩下跳法是f(n-2)
  所以`f(n) = f(n-1) + f(n - 2) +...+ f(1)`
  =>`f(n-1) = f(n-2) + f(n-3) +...+ f(1)`
  =>`f(n) = 2 * f(n-1)`
  即求 ` 2 的 (n-1) 次方`
  注意：右移一位相当于除2，右移n位相当于除以2的n次方；左移一位相当于乘以2，左移n为相当于乘以2的n次方

```js
/* 通过左移运算符求解 */
jumpFloor = (n) => 1 << (n - 1)
console.log(jumpFloor(15));

/* 通过Math内置方法求解 2 ^ (n-1) */
jumpFloorII = (n) => Math.pow(2, n - 1)
console.log(jumpFloorII(15));

/* 通过递归求解 */
jumpFloorIII = (n) => {
  if (n <= 0) return;
  else if (n === 1) return 1;
  else if (n === 2) return 2;
  else return 2 * jumpFloorIII(n - 1);
}
console.log(jumpFloorIII(15));
```

### list转换树形菜单

````js
function convert(list) {
  const res = []
  const map = list.reduce((res, v) => (res[v.id] = v, res), {})
  for (const item of list) {
    if (item.parentId === 0) {
      res.push(item)
      continue
    }
    if (item.parentId in map) {
      const parent = map[item.parentId]
      parent.children = parent.children || []
      parent.children.push(item)
    }
  }
  return res
}
let list = [
  { id: 1, name: '部门A', parentId: 0 }, { id: 2, name: '部门B', parentId: 0 },
  { id: 3, name: '部门C', parentId: 1 }, { id: 4, name: '部门D', parentId: 1 },
  { id: 5, name: '部门E', parentId: 2 }, { id: 6, name: '部门F', parentId: 3 },
  { id: 7, name: '部门G', parentId: 2 }, { id: 8, name: '部门H', parentId: 4 }
];
console.log(convert(list));
````

### 数组中第K个最大元素

```js
/*输入: [3,2,1,5,6,4] 和 k = 2；	输出: 5
  输入: [3,2,3,1,2,4,5,5,6] 和 k = 4；		输出: 4*/
function findKthLargest(nums, k) {
  if (1 <= k <= nums.length) {
    nums.sort((a, b) => b - a)	// 从大到小排序(不去重)
    return nums[k - 1]	// 返回第k-1个元素
  }
  return false
};
console.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4))
```

### 数组排序

```js
/* 在一个字符串数组中有红、黄、蓝三种颜色的球，且个数不相等、顺序不一致，请为该数组排序。使得排序后数组中球的顺序为:黄、红、蓝。
例如：红蓝蓝黄红黄蓝红红黄红，排序后为：黄黄黄红红红红红蓝蓝蓝。 */
let str = '红蓝蓝黄红黄蓝红红黄红'
let obj = {'黄': 0,'红':1, '蓝': 2}
let arr = str.split('').sort((a, b) => {
  return obj[a] - obj[b]
})
console.log(arr.join(''))  // 黄黄黄红红红红红蓝蓝蓝
```

### 查找数组

```js
/* 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案
输入：nums = [2,7,11,15], target = 9;   输出：[0,1]
输入：nums = [3,2,4], target = 6;   输出：[1,2]
输入：nums = [3,3], target = 6;   输出：[0,1] */
var twoSum = function (nums, target) {
  for (let i = 0; i < nums.length; i++) {
    let a = nums.indexOf(target - nums[i], i + 1)
    if (a > 0) return [i, a]
  }
};
```

### 两数相加

```js
/* 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
输入：digits = [1,2,3], 输出：[1,2,4]
输入：digits = [4,3,2,1], 输出：[4,3,2,2]
输入：digits = [0], 输出：[1] */
let digits = [4,3,2,1]
((BigInt(digits.join('')) + 1n) +'').split('')	// [4,3,2,2]
```

```js
/* 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
输入：l1 = [2,4,3], l2 = [5,6,4],   输出：[7,0,8]
输入：l1 = [0], l2 = [0],   输出：[0]
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]; 输出：[8,9,9,9,0,0,0,1] */
var addTwoNumbers = function (l1, l2) {
  len = l1.length > l2.length ? l1.length : l2.length	// 获取最长的数组长度
  let l3 = Array(len).fill(0);
  for (let i = 0; i < len; i++) {
    l1[i] = l1[i] || 0, l2[i] = l2[i] || 0;	// 防止超过长度存在数据未定义，导致相加失败
    let flag = l1[i] + l2[i] + l3[i];
    if (flag > 9) {	// 当相加大于9，则向后一位加1，本身取相加所得的个位数
      l3[i] = flag % 10;
      l3[i + 1] = 1;
    } else {
      l3[i] = flag;
    }
  }
  return l3
};

// 优化写法  因为可以看为是两个数相加，然后倒叙即为所求结果
var addTwoNumbers = function (l1, l2) {
  return ((BigInt(l1.join('')) + BigInt(l2.join(''))) + '').split('').reverse().map(Number)
};
let l1 = [0, 1, 1, 3], l2 = [9, 9, 9, 9, 9, 9, 9, 9, 9]
console.log(addTwoNumbers(l1, l2))
```

### 无重复字符的最长子字符串

- 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

```js
/* 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
输入: s = "abcabcbb";   输出: 3 
输入: s = "bbbbb";    输出: 1
输入: s = "pwwkew";   输出: 3 
输入: s = "";         输出: 0
思路：如果当前位置的字符重复，则取重复字符后的字符 + 当前位置的字符 */
let s = "abcabcbb"
var lengthOfLongestSubstring = function (s) {
    let sum = '', max = 0;
    for (let i = 0; i < s.length; i++) {
        let current = s.charAt(i);  // 获取当前位置的字符
        sum.indexOf(current) > -1 // 如果当前位置的字符重复，则取重复字符后的字符 + 当前位置的字符
            ? sum = sum.substring(sum.indexOf(current) + 1) + current // 截取出现字符重复之后的所有字符
            : sum += current;
        max = max < sum.length ? sum.length : max;
    }
    return max
};
console.log(lengthOfLongestSubstring(s))
```

### 寻找两个正序整数的中位数

```js
/* 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数
输入：nums1 = [1,3], nums2 = [2];	输出：2.00000
输入：nums1 = [1,2], nums2 = [3,4];	输出：2.50000
*/
var findMedianSortedArrays = function(nums1, nums2) {
    let nums = [...nums1, ...nums2].sort((a,b) => a - b)
    let len = nums.length
    return len % 2 === 0 ? (nums[len/2] + nums[len/2 -1])/2 : nums[Math.floor(len/2)]
};
let nums1 = [1,2], nums2 = [3,4]
console.log(findMedianSortedArrays(nums1, nums2))
```

### 手写红绿灯

> 使用callbak、promise、async…await、genteror编写 3秒打印一个红 二秒绿 1秒黄
>
> ```js
> // promise
> new Promise((resolve, reject) => {
> setTimeout(() => {
> console.log('red')
>  return Promise.resolve('green').then(res => {
>    setTimeout(() => {
>      console.log(res)
>        return Promise.resolve('yellow').then(res => {
>           setTimeout(() => {
>             console.log(res)
>           }, 1000)
>         })
>       }, 2000)
>     })
>    }, 3000)
>    })
>    ```
>    
>    ```js
>   // async...await
> const changeColor = (color, timer) => {
> return new Promise((resolve, reject) => {
> setTimeout(() => {
>    console.log(color)
>    resolve(color)
>  }, timer)
>   })
>    }
>    const getColor = async () => {
>    try {
>     await changeColor('red', 3000);
>    await changeColor('green', 2000);
>  await changeColor('yellow', 1000)
> } catch (err) { }
>   }
>    getColor()
>    ```
>    
>   ```js
> // generaotor
> function* showColor() {
> yield getColor('red', 3000)
>yield getColor('green', 2000)
> yield getColor('yellow', 1000)
> }
> function getColor(color, timer) {
> setTimeout(() => {
> console.log(color)
> }, timer)
> }
> let arr = showColor();
> arr.next();
>  arr.next();
> arr.next();
> ```
> 
> 



# 算法基础

### 堆栈

- 栈是一个线性结构，特点是只能在某一端添加或删除数据，遵循先进后出的原则。
- 对于一个栈，需要实现添加、删除元素、获取栈顶元素、已经是否为空，栈的长度、清除元素等几个基本操作

```js
function Stack() {
  this.items = [];
}
Stack.prototype = {
  constructor: Stack,
  push: function (element) {	// 在栈顶添加数据
    this.items.push(element);
  },
  pop: function () {	// 移除栈顶数据
    return this.items.pop();
  },
  peek: function () {	// 获取栈顶数据
    return this.items[this.items.length - 1];
  },
  isEmpty: function () {	// 判断栈是否为空
    return this.items.length === 0;
  },
  clear: function () {	// 清空栈
    this.items = [];
  },
  size: function () {	// 查看栈的大小
    return this.items.length;
  },
  print: function () {	// 输出栈数据
    console.log(this.items.toString());
  }
}
let stack = new Stack();
stack.items = [1, 2, 3];
stack.push('a');
console.log(stack.isEmpty());
```

#### 例：匹配括号

- 通过栈先进后出的特点来判断是否形成闭环

```js
let isValid = function (str) {
  strArr = str.split('');	// 字符串转数组
  let map = {
    '(': -1, ')': 1,
    '[': -2, ']': 2,
    '{': -3, '}': 3,
  }
  let stack = [];
  for (let i = 0; i < strArr.length; i++) {
    if (map[strArr[i]] < 0) {
      stack.push(strArr[i])  // 左括号入栈
    } else {	
      // 判断是否为右括号 且 是否形成闭环
      // (注意：需要数据是右括号才行，否则会破坏数据结构)
      if (map[strArr[i]] > 0 && map[stack.pop()] + map[strArr[i]] != 0) return false;
    }
  }
  return stack.length == 0
}
console.log(isValid('{9()8}'))  // true
console.log(isValid('{9(])8}'))  // false
console.log(isValid('{222)'))  // false
console.log(isValid('{'))   // false
```



### 队列

- 队列是线性结构，遵循先进先出原则，特点是在某一端添加数据，在另一端删除数据

**单链队列**

```js
class Queue {
  constructor () {
    this.queue = [];
  }
  enQueue(item) {
    this.queue.push(item);
  }
  delQueue() {
    return this.queue.shift();
  }
  getHeader() {
    return this.queue[0]
  }
  getLength() {
    return this.queue.length;
  }
  isEmpty() {
    return this.queue.length === 0;
  }
  clear() {
    return this.queue = []
  }
}
```

**循环队列**

- 因为单链队列出队操作的时间复杂度为O(n)，而循环队列的出队操作的时间复杂度为O(1)

```js
class SqQueue {
  constructor(length) {
    this.queue = new Array(length + 1);
    this.first = 0; // 队头
    this.last = 0;  // 队尾
    this.size = 0;  // 队列大小
  }
  pushQueue(item) {
    //  % this.queue.length 是为了防止数组越界
    if (this.first === (this.last + 1) % this.queue.length) {
      this.resize(this.getLength() * 2 + 1)
    }
    this.queue[this.last] = item;
    this.size++;
    this.last = (this.last + 1) % this.queue.length;
  }
  delQueue() {
    if (this.isEmpty()) {
      throw Error('Queue is empty')
    }
    let r = this.queue[this.first]
    this.queue[this.first] = null
    this.first = (this.first + 1) % this.queue.length
    this.size--
    // 为了保证不浪费空间，在队列空间等于总⻓度四分之⼀且不为2时,缩⼩总⻓度为当前的⼀半
    if (this.size === this.getLength() / 4 && this.getLength() / 2 !== 0) {
      this.resize(this.getLength() / 2)
    }
    return r
  }
  getHeader() {
    if (this.isEmpty()) {
      throw Error('Queue is empty')
    }
    return this.queue[this.first]
  }
  getLength() {
    return this.queue.length - 1;
  }
  isEmpty() {
    return this.first === this.last
  }
  resize(length) {
    let q = new Array(length)
    for (let i = 0; i < length; i++) {
      q[i] = this.queue[(i + this.first) % this.queue.length]
    }
    this.queue = q;
    this.first = 0;
    this.last = this.size;
  }
}
let quese = new SqQueue(10);
quese.pushQueue('a')
console.log(quese)	// SqQueue { queue: [ 'a', <10 empty items> ], first: 0, last: 1, size: 1 }
```





### 链表





### 波兰式/逆波兰式

- 波兰式是在通常的表达式中，二元运算符总是置于与之相关的两个运算对象之前，所以，这种表示法也称为前缀表达式。
- ![image-20210922154737326](image/image-20210922154737326.png)
- 在后缀表示中，运算符按实际计算顺序从左到右排列，且每一运算符总是跟在其运算对象之后。
  - ![image-20210922154852540](image/image-20210922154852540.png)
  - 中缀表达式：`A+B*(C-D)-E*F`
  - 前缀表达式(波兰式)：`- + A * B - C D * E F`
  - 后缀表达式(逆波兰式)：`A B C D - * + E F * -`



### 深度优先遍历`DFS`

- DFS 一般是解决连通性问题，而 BFS 一般是解决最短路径问题
- 深度优先遍历是DFS：从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底...，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。

![image-20211018114908765](image/image-20211018114908765.png)

```js
/*深度优先遍历三种方式*/
let deepTraversal1 = (node, nodeList = []) => {
  if (node !== null) {
    nodeList.push(node)
    let children = node.children
    if (children == [] && children.length > 0)
      for (let i = 0; i < children.length; i++) {
        deepTraversal1(children[i], nodeList)
      }
  }
  return nodeList
}
let deepTraversal2 = (node) => {
  let nodes = []
  if (node !== null) {
    nodes.push(node)
    let children = node.children
    if (children == [] && children.length > 0)
      for (let i = 0; i < children.length; i++) {
        nodes = nodes.concat(deepTraversal2(children[i]))
      }
  }
  return nodes
}
// 非递归
let deepTraversal3 = (node) => {
  let stack = [], nodes = []
  if (node) {
    // 推入当前处理的node
    stack.push(node)
    while (stack.length) {
      let item = stack.pop()
      let children = item.children
      nodes.push(item)
      if (children == [] && children.length > 0)
        for (let i = children.length - 1; i >= 0; i--) {
          stack.push(children[i])
        }
    }
  }
  return nodes
}
```

####  例：根据子节点寻找父节点

```js
/* 利用遍历来寻找父节点的位置 */
treeFindPath(tree, func, path = []) {
  if (!tree) return []
  for (const data of tree) {
    path.push(data.code)
    if (func(data)) return path
    if (data.children) {
      const findChildren = treeFindPath(data.children, func, path)
      if (findChildren.length) return findChildren
    }
    path.pop()
  }
  return []
};
let ssfj = treeFindPath(treeData,data=> data.code==rows[0].werks && data.type == 30);
```



### 广度优先遍历`BFS`

- 广度优先遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。
- 广度优先遍历`BFS`，会从起点开始“一层一层”扩展的方法来遍历，扩展时每发现一个点就将这个点加入到队列中，知道整张图都被遍历过位置

![img](image/29dc30c1546cc73846153359b0fad8fb.gif)

```js
let widthTraversal2 = (node) => {
  let nodes = []
  let stack = []
  if (node) {
    stack.push(node)
    while (stack.length) {
      let item = stack.shift()
      let children = item.children
      nodes.push(item)
      // 队列，先进先出
      if (children == [] && children.length > 0)
        for (let i = 0; i < children.length; i++) {
          stack.push(children[i])
        }
    }
  }
  return nodes
}
```



# 排序算法

![img](image/1089184-20170118180823468-388996114.png)

### 冒泡排序

**原理：从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素**

> 冒泡排序是从低到高（或从高到低）的单向排序。
>
> 注意：一般来说，排好序的元素都是放在数组最后面（因为大的会放后面），所以第二个循环要`-i`

![åæ³¡æåº](image/bubbleSort.gif)

```js
/* 冒泡排序 */
bubbleSort = (arr) => {
  let len = arr.length;
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {	// -i 是因为最后面的元素都已经排好序，不需要再比较
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
    console.log("冒泡排序：", arr);
  return arr;
}
bubbleSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7]);  // [ 1, 2, 2, 3, 4, 4, 5, 5, 7, 7, 8, 9, 9 ]
```

#### 双向冒泡排序（鸡尾酒排序）

**原理：双向冒泡排序是从2个方向进行排序，“较大气泡从左到右移动，较小气泡从右到左移动”，2边遍历指针相遇时，排序结束。**

```js
/* 鸡尾酒排序 */
// 双向冒泡排序是从2个方向进行排序，奇数趟从低到高，偶数趟从高到底，2边遍历指针相遇时，排序结束。
bothwayBubbleSort = (arr) => {
  let left = 0, right = arr.length - 1;
  while (left < right) {
    for (let i = left + 1; i <= right; i++) { // 较大起泡从左向右移动
      if (arr[left] > arr[i]) {
        [arr[left], arr[i]] = [arr[i], arr[left]];
      }
    }
    left++;
    for (let i = right - 1; i >= left; i--) { // 较小起泡从右向左移动
      if (arr[i] > arr[right]) {
        [arr[right], arr[i]] = [arr[i], arr[right]];
      }
    }
    right--;
  }
  console.log("双向冒泡排序：", arr);
  return arr;
}
bothwayBubbleSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7]);  // "双向冒泡排序：" [ 1, 2, 2, 3, 4, 4, 5, 5, 7, 7, 8, 9, 9 ]
```

### 选择排序

**原理：遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作。**

![img](image/1342059-20190514171046967-1633143483.gif)

```js
selectionSort = (arr) => {
  for (let i = 0; i < arr.length - 1; i++) {
    let minindex = i;
    for (let j = i + 1; j < arr.length; j++) {
      minindex = arr[j] < arr[minindex] ? j : minindex;
    }
    [arr[i], arr[minindex]] = [arr[minindex], arr[i]]
  }
  console.log(arr);
  return arr;
}
selectionSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7]);
```

### 插入排序

#### 直接插入排序

**原理：第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。**

![img](image/1342059-20190514171140724-291814375.gif)

```js
/* 插入排序
取后面的数跟前面的数比较，如果比前面的数小，则放到前面去；直到前面没有数比他小为止
如果比前面的数大，则跳出此次，开始下一次循环 */
insertSort = arr => {
  let i = 1;
  for (let i = 1; i < arr.length; i++) {
    for (let j = i; j > 0; j--) {
      if (arr[j] >= arr[j - 1]) {
        break;
      } else {
        [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]];
        console.log("调换顺序的位置：",j,"，值：",arr[j-1],arr[j])
      }
    }
  }
  console.log(arr);
  return arr;
}
insertSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7]);  // 插入排序： [ 1, 2, 2, 3, 4, 4, 5, 5, 7, 7, 8, 9, 9 ]
```

#### 折半（二分）插入排序

直接插入排序的升级版，插入时与已排序好的序列的中间值（除2向下取整）对比，可缩小一般的对比范围。

```js
function binaryInsertionSort(array){
    var current, i, j, low, high, m;
    for(i = 1; i < array.length; i++){
        low = 0;
        high = i - 1;
        current = array[i];
        
        while(low <= high){            //步骤1&2:折半查找
            m = (low + high)>>1;
            if(array[i] >= array[m]){//值相同时, 切换到高半区，保证稳定性
                low = m + 1;        //插入点在高半区
            }else{
                high = m - 1;        //插入点在低半区
            }
        }
        for(j = i; j > low; j--){     //步骤3:插入位置之后的元素全部后移一位
            array[j] = array[j-1];
        }
        array[low] = current;         //步骤4:插入该元素
    }
    return array;
}
```

`x>>1`是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即`x>>1 == Math.floor(x/2)`.



### 希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
- 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录`基本有序`时，再对全体记录进行依次直接插入排序。

原理：

1. 将数组拆分为若干个子分组, 每个分组由相距一定”增量”的元素组成.
2. 然后对每个子分组应用直接插入排序.
3. 逐步减小”增量”, 重复步骤1,2.
4. 直至”增量”为1, 这是最后一个排序, 此时的排序, 也就是对全数组进行直接插入排序.

一般情况下，增量 = 待分组序列长度 / 2 ，向下取整

![image-20210922185514310](image/image-20210922185514310.png)

```js
function shellSort(arr) {
  let gap = arr.length <= 2 ? 1 : Math.floor(arr.length / 2); //动态定义间隔序列
  for (gap; gap > 0; gap = Math.floor(gap / 2)) {
    for (let i = gap; i < arr.length; i++) {
      let temp = arr[i];
      let j = i - gap;
      for (; j >= 0 && arr[j] > temp; j -= gap) {
        arr[j + gap] = arr[j];
      }
      arr[j + gap] = temp;
    }
  }
  console.log(arr)
  return arr;
}
shellSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7]);
```







### 归并排序

原理：

（1） 把长度为n的输入序列分成两个长度为n/2的子序列；

（2）对这两个子序列分别采用归并排序；

（3） 将两个排序好的子序列合并成一个最终的排序序列。

![img](image/1342059-20190514171753267-9059541.gif)

```js
function mergeSort(arr) {  //采用自上而下的递归方法
  var len = arr.length;
  if (len < 2) {
    return arr;
  }
  var middle = Math.floor(len / 2),
    left = arr.slice(0, middle),
    right = arr.slice(middle);
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  var result = [];
  while (left.length && right.length) {
    // 不断比较left和right数组的第一项，小的取出存入res
    left[0] < right[0] ? result.push(left.shift()) : result.push(right.shift());
  }
  return result.concat(left, right);
}
```

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
将数组拆分为两个子数组, 分别排序, 最后才将两个子数组合并; 拆分的两个子数组, 再继续递归拆分为更小的子数组, 进而分别排序, 直到数组长度为1, 直接返回该数组为止。

归并排序可通过两种方式实现：

1. 自上而下的递归
2. 自下而上的迭代

```js
function mergeSort(arr) {  // 采用自上而下的递归方法
  var len = arr.length;
  if (len < 2) {
    return arr;
  }
  var middle = Math.floor(len / 2),
    left = arr.slice(0, middle),
    right = arr.slice(middle);
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  var result = [];

  while (left.length && right.length) {
    if (left[0] <= right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }

  while (left.length)
    result.push(left.shift());

  while (right.length)
    result.push(right.shift());

  return result;
}
```

### 快速排序

**原理：在数据集之中，找一个基准点，建立两个数组，分别存储左边和右边的数组，利用递归进行下次比较，, 直到数组不可拆分, 排序完成**

1. 从数列中挑出一个元素，称为 "基准"（pivot）;
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

![å¿«éæåº](image/quickSort.gif)

```js
function quickSort(arr) {
  if (!Array.isArray(arr)) return;
  if (arr.length <= 1) return arr;
  let left = [], right = [];
  let num = Math.floor(arr.length / 2);
  let numValue = arr.splice(num, 1)[0];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > numValue) {
      right.push(arr[i]);
    } else {
      left.push(arr[i]);
    }
  }
  return [...quickSort(left), numValue, ...quickSort(right)]
}
let arr = quickSort([2, 5, 2, 1, 4, 7, 9, 4, 9, 3, 5, 8, 7]);
console.log(arr)
```





### 堆排序

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

1. 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
2. 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

------

1. 比较父节点是否大于叶子节点（把最大的放在父子节点），直到一趟建堆完成，最大的一定在堆顶。
2. 把堆顶和最右下的叶子节点对换，再把右下叶子节点（最大值）抽出。

![å æåº](image/heapSort.gif)

```js
var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) {   // 建立大顶堆
  len = arr.length;
  for (var i = Math.floor(len / 2); i >= 0; i--) {
    heapify(arr, i);
  }
}

// 2 * i  非叶子节点
function heapify(arr, i) {     // 堆调整
  var left = 2 * i + 1,
    // 左叶子节点
    right = 2 * i + 2,
    // 右叶子节点
    largest = i;

  if (left < len && arr[left] > arr[largest]) {
    largest = left;
  }

  if (right < len && arr[right] > arr[largest]) {
    largest = right;
  }

  if (largest != i) {
    swap(arr, i, largest);
    heapify(arr, largest);
  }
}

function swap(arr, i, j) {
  var temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

function heapSort(arr) {
  buildMaxHeap(arr);

  for (var i = arr.length - 1; i > 0; i--) {
    swap(arr, 0, i);
    len--;
    heapify(arr, 0);
  }
  return arr;
}
```





### 计数排序

计数排序是唯一不基于比较的排序算法。
计数排序不是比较排序，排序的速度快于任何比较排序算法。
适合处理一定范围内的整数排序。
计数排序利用了一个特性, 对于数组的某个元素, 一旦知道了有多少个其它元素比它小(假设为m个), 那么就可以确定出该元素的正确位置(第m+1位)

1. 找出待排序的数组中最大和最小的元素
2. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
4. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

------

1. 花O(n)时间获取数组A的最小值min，最大值max
2. 开辟新的空间创建新数组B，长度为(`max - min + 1`)
3. B中`index`元素记录的是A中某元素出现的次数
4. 遍历数组B，输出相应的元素及其个数

![è®¡æ°æåº](image/countingSort.gif)

```js
function countingSort(arr, maxValue) {
  var bucket = new Array(maxValue + 1),
    sortedIndex = 0;
  arrLen = arr.length,
    bucketLen = maxValue + 1;

  for (var i = 0; i < arrLen; i++) {
    if (!bucket[arr[i]]) {
      bucket[arr[i]] = 0;
    }
    bucket[arr[i]]++;
  }

  for (var j = 0; j < bucketLen; j++) {
    while (bucket[j] > 0) {
      arr[sortedIndex++] = j;
      bucket[j]--;
    }
  }

  return arr;
}
```



### 桶排序

桶排序（箱排序）是计数排序的升级版。
它是将数组分配到有限数量的桶子里. 每个桶里再各自排序(因此有可能使用别的排序算法或以递归方式继续桶排序). 当每个桶里的元素个数趋于一致时, 桶排序只需花费O(n)的时间.
桶排序的核心就在于怎么把元素平均分配到每个桶里, 合理的分配将大大提高排序的效率.
当输入的数据可以均匀的分配到每一个桶中的时候最快。

![æ¡¶æåº2](image/Bucket_sort_2.svg_.png)

```js
function bucketSort(arr, bucketSize) {
  if (arr.length === 0) {
    return arr;
  }

  var i;
  var minValue = arr[0];
  var maxValue = arr[0];
  for (i = 1; i < arr.length; i++) {
    if (arr[i] < minValue) {
      minValue = arr[i];                // 输入数据的最小值
    } else if (arr[i] > maxValue) {
      maxValue = arr[i];                // 输入数据的最大值
    }
  }

  //桶的初始化
  var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
  var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;
  var buckets = new Array(bucketCount);
  for (i = 0; i < buckets.length; i++) {
    buckets[i] = [];
  }

  //利用映射函数将数据分配到各个桶中
  for (i = 0; i < arr.length; i++) {
    buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
  }

  arr.length = 0;
  for (i = 0; i < buckets.length; i++) {
    insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
    for (var j = 0; j < buckets[i].length; j++) {
      arr.push(buckets[i][j]);
    }
  }

  return arr;
}
```



### 基数排序

基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。
按照优先从高位或低位来排序有两种实现方案:

- MSD: 由高位为基底, 先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列. MSD方式适用于位数多的序列.
- LSD: 由低位为基底, 先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列. LSD方式适用于位数少的序列.

![åºæ°æåº](image/radixSort.gif)

```js
function radixSort(array, max) {
  var buckets = [],
    unit = 10,
    base = 1;
  for (var i = 0; i < max; i++, base *= 10, unit *= 10) {
    for (var j = 0; j < array.length; j++) {
      var index = ~~((array[j] % unit) / base);//依次过滤出个位,十位等等数字
      if (buckets[index] == null) {
        buckets[index] = []; //初始化桶
      }
      buckets[index].push(array[j]);//往不同桶里添加数据
    }
    var pos = 0,
      value;
    for (var j = 0, length = buckets.length; j < length; j++) {
      if (buckets[j] != null) {
        while ((value = buckets[j].shift()) != null) {
          array[pos++] = value; //将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞
        }
      }
    }
  }
  return array;
}
```



# 设计模式

- **创建型模式**，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
- **结构型模式**，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
- **行为型模式**，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

**设计模式的六大原则**

| 原则                          | 解释                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| **单一原则 （SRP）**          | **一个类只做一件事**                                         |
| **开放-封闭原则（OCP）**      | **软件实体（类、模块、函数）可以拓展，但是不可修改**         |
| **依赖倒转原则（DIP）  **     | **A.高层模块不应该依赖底层，两个都应该依赖抽。B.抽象不应该依赖细节，细节依赖抽象** |
| **里氏代换原则（LSP）**       | **子类型必须能够替换掉它们的父类型**                         |
| **迪米特法则（LoD）**         | **如果两个类不必直接通信，那么这两个类不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可通过第三者发起这个调用** |
| **合成/聚合复用原则（CARP）** | **尽量使用合成/聚合，尽量不要使用类继承**                    |

## 创建型模式

### 工厂模式

**工厂模式是一种用来创建对象的设计模式。我们不暴露对象创建的逻辑,而是将逻辑封装在一个函数内,那么这个函数可以成为工厂。**

**工厂模式根据抽象程度的不同可以分为：1.简单工厂 2.工厂方法 3.抽象工厂**

#### 简单工厂模式

```js
let factory = function (role) {
  function superman() {
    this.name = '超级管理员';
    this.role = ['修改密码', '发布消息', '查看主页']
  }

  function commonMan() {
    this.name = '普通游客';
    this.role = ['查看主页']
  }

  switch (role) {
    case 'superman':
      return new superman();
      break;
    case 'man':
      return new commonMan();
      break;
    default:
      throw new Error('参数错误')
  }

}

let superman = factory('superman');
let man = factory('man');
console.log(superman, man)
```

factory就是一个简单的工厂,该工厂中有二个构造函数分别对应不同的权限。我们只需要传递相应的参数就可以获取一个实例对象了。工厂内部的构造函数有相似的地方,还可以进一步优化。

#### 简单工厂优化

```js
let factory = function (role) {
  function User(obj) {
    this.name = obj.name;
    this.role = obj.role;
  }
  switch (role) {
    case 'superman':
      return new User({ name: '平台用户', role: ['主页', '登录页'] })
      break;
    case 'man':
      return new User({ name: '游客', role: ['登录页'] })
      break;
    default:
      throw new Error('参数错误')
  }
}

let superman = factory('superman');
let man = factory('man');
console.log(superman, man)
```

简单工厂的优点: 你只需要传递一个合法的参数,就可以获取到你想要的对象,而无需知道创建的具体的细节。
简单工厂的缺点：但是在函数内包含了所有对象的构造函数和判断逻辑的代码, 每次如果需要添加一个对象,那么则需要新增一个构造函数,当我们需要维护的对象过多,那么这个函数将会成为超级函数,使得我们难以维护。
所以简单工厂模式只适用于在创建时对象数量少,以及逻辑简单的情况。

#### 工厂方法

工厂方法模式本意是将实际创造的对象推迟到子类中,这样核心类就变成了抽象类。但是在js中很难像那些传统面向对象语言那样去实现抽象类,所以在js中我们只需要参考他的思想即可。

我们可以把工厂函数看成是一个工厂类。在简单模式我们,我们添加一个新的对象需要修改二处地方,在加入工厂方法模式以后,我们只需要修改一处即可。工厂方法的工厂类,他只做实例化这一件事情。我们只需要修改他的原型类即可。我们采用安全模式创建工厂对象。

```js
let factory = function (role) {
  if (this instanceof factory) {
    var s = new this[role]();
    return s;
  } else {
    return new factory(role);
  }
}

factory.prototype = {
  admin: function () {
    this.name = '平台用户';
    this.role = ['登录页', '主页']

  },
  common: function () {
    this.name = '游客';
    this.role = ['登录页']
  },
  test: function () {
    this.name = '测试';
    this.role = ['登录页', '主页', '测试页'];
    this.test = '我还有一个测试属性哦'
  }
}

let admin = new factory('admin');
let common = new factory('common');
let test = new factory('test');
```



### 单例模式

- 单例模式的核心是保证全局只有一个对象可以访问。因为JS不存在类，所以其他语言实现单例的方式不能套入JS中，我们只需用一个变量确保实例只创建一次就行
- 如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式

```js
class Singleton {
   constructor() {}
}
Singleton.getInstance = (function() {
   let instance
   return function() {
      if(!instance) {
         instance = new Singleton()
      }
      return instance
   }
})()
let s1 = Singleton.getInstance()
let s2 = Singleton.getInstance()
console.log(s1 === s2) // true
```

```js
// 如：VUEX中使用单例模式
let Vue
export function install(_Vue) {
  if(Vue && _Vue === Vue) {
    // 如果发现Vue有值,就不重新创建实例
    return
  }
  Vue = _Vue
  applyMixin(Vue)
}
```

### 适配器模式





### 装饰模式

- 装饰模式不需要改变已有的接口，作用是给对象添加功能。如给手机戴保护套防摔，不改变手机自身而给手机添加保护套提供防摔功能。

```js
// 使用 ES7 中装饰器语法（React中使用）
function readonly(target, key, descriptor) {
  descriptor.writable = false
  return descriptor
}
class Test {
  // 使用装饰器
  @readonly
  name = 'willy'
}
let t = new Test()
// t.name = '1'	// 不可修改
```

```js
//  React中随处可见的装饰模式
import { connect } from 'react-redux'
class MyComponent extends React.Component {
  // ...具体逻辑
}
export default connect(mapStateToProps)(MyComponent)
```





### 代理模式

- 代理是为了控制对对象的访问，不让外部直接访问到对象。如需要买国外的产品可通过代购来购买产品。
- 如：事件代理就用到代理模式（通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的结点）

```html
<ul id="ul">
  <li>1</li>
  <li>2</li>
</ul>
<script>
	let ul = document.querySelector("#ul");
  ul.addEventListener('click', (event) => {
    console.log(event.target);
  })
</script>
```



### 发布-订阅模式

- 发布-订阅模式也叫观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会受到通知。
- 如点击一个按钮触发了点击事件就是使用该模式；
  还有vue的响应式也是使用该模式，在get时会进行依赖更新，当改变了对象的属性时，就会触发派发更新。

```html
<ul id="ul"></ul>
<script>
	let ul = document.querySelector("#ul");
  ul.addEventListener('click', (event) => {
    console.log(event.target);
  })
</script>
```



### 外观模式

- 外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部调用
- 如实现一个兼容多种浏览器的添加事件方法

```js
function addEvent(elm, evType, fn, useCapture) {
  if (elm.addEventListener) {
    ele.addEventListener(evType, fn, useCapture);
    return true;
  } else if (elm.attachEvent) {
    return ele.attachEvent("on" + evType, fn);
  } else {
    elm["on" + evType] = fn;
  }
}
```

